# -*- python -*-
# ex: set syntax=python:

# This is a sample buildmaster config file. It must be installed as
# 'master.cfg' in your buildmaster's base directory.

# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}

def mergeRequests(builder, req1, req2):
    "any requests with the same branch can be merged"
    return req1.branch == req2.branch

c['mergeRequests'] = mergeRequests

####### Log horizons

c['changeHorizon'] = 200
c['buildHorizon'] = 100
c['eventHorizon'] = 50
c['logHorizon'] = 50

####### BUILDSLAVES

# The 'slaves' list defines the set of recognized buildslaves. Each element is
# a BuildSlave object, specifying a unique slave name and password.  The same
# slave name and password must be configured on the slave.
from buildbot.buildslave import BuildSlave
c['slaves'] = [BuildSlave("server", "MySlav3Pa55W0rd", max_builds=1),
	BuildSlave("saturn", "MySlav3Pa55W0rd", max_builds=1),
	BuildSlave("desktop", "MySlav3Pa55W0rd", max_builds=1),
	BuildSlave("jupiter", "MySlav3Pa55W0rd", max_builds=1),
	BuildSlave("minecraft", "MySlav3Pa55W0rd", max_builds=1)]

# 'slavePortnum' defines the TCP port to listen on for connections from slaves.
# This must match the value configured into the buildslaves (with their
# --master option)
c['slavePortnum'] = 9989

####### CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes.

from buildbot.changes.gitpoller import GitPoller
c['change_source'] = []

####### SCHEDULERS

# Configure the Schedulers, which decide how to react to incoming changes.  In this
# case, just kick off a 'runtests' build

from buildbot.schedulers.basic import SingleBranchScheduler
from buildbot.schedulers.forcesched import ForceScheduler
from buildbot.changes import filter
c['schedulers'] = []

####### LOCKS

from buildbot import locks

build_lock = locks.SlaveLock("slave_builds", maxCount = 1,
		maxCountForSlave = {
			'server' : 1,
			'saturn' : 1,
			'desktop' : 1,
			'jupiter' : 1,
			'minecraft' : 1
		})

####### BUILD CONFIGURATION

# hwmon

hwmon_repo = 'git://server.roeck-us.net/git/linux.git'
hwmon_branches = [ 'hwmon', 'hwmon-next', 'hwmon-staging' ]
hwmon_slaves = [ 'server', 'desktop', 'saturn', 'jupiter', 'minecraft' ]

# stable

stable_repo = 'git://server.roeck-us.net/git/linux-stable.git'

stable_branches = [ '3.0', '3.4', '3.10', 'master' ]
stable_queue_branches = [ 'linux-3.0.y.queue', 'linux-3.4.y.queue', 'linux-3.10.y.queue', 'master' ]
stable_slaves = [ 'server', 'desktop', 'saturn', 'jupiter' ]

stable_arches = [ 'alpha', 'arc', 'arm', 'arm64', 'avr32', 'blackfin', 'cris',
		'frv', 'i386', 'ia64', 'm68k', 'm68k_nommu', 'microblaze',
		'mips', 'parisc', 'parisc64', 'powerpc', 's390', 'sh',
		'sparc32', 'sparc64', 'tile', 'x86_64', 'xtensa', 'um']

qemu_targets_30 = [ 'ppc', 'x86', 'x86_64' ]
qemu_targets_34 = [ 'mips', 'microblaze', 'mips64', 'ppc', 'x86', 'x86_64' ]
qemu_targets_310 = [ 'arm', 'microblaze', 'mips', 'mips64', 'ppc', 'x86', 'x86_64' ]
qemu_targets_master = [ 'arm', 'microblaze', 'mips', 'mips64', 'ppc', 'x86', 'x86_64' ]

####### BUILDERS

def getBuilderPriority(builder):
    try:
        return builder.config.properties.get("priority", 0)
    except Exception as e:
	return 5

def prioritizeBuilders(buildmaster, builders):
    builders.sort(key=getBuilderPriority)
    return builders

c['prioritizeBuilders'] = prioritizeBuilders

# The 'builders' list defines the Builders, which tell Buildbot how to perform a build:
# what steps, and which slaves can execute them.  Note that any particular build will
# only take place on one slave.

from buildbot.process.factory import BuildFactory
from buildbot.steps.source.git import Git
from buildbot.steps.shell import ShellCommand
# from buildbot.steps.shell import Test
from buildbot.config import BuilderConfig
from buildbot.process.buildstep import LogLineObserver
from buildbot.status.builder import SUCCESS,WARNINGS,FAILURE,EXCEPTION,RETRY,SKIPPED

c['builders'] = []
force = []

import re

passed = re.compile('Building (\S+):(\S+) \.\.\. passed$')
failed = re.compile('Building (\S+):(\S+) \.\.\. failed$')
skipped = re.compile('Building (\S+):(\S+) \.\.\. failed \(config\)')

def prevFailed(step):
    allSteps = step.build.getStatus().getSteps()
    sprev = allSteps[-1]
    for s in allSteps:
        (started, finished) = s.getTimes()
        if started and finished:
            sprev = s
        else:
            break
    result = sprev.getResults()[0]
    return result in (FAILURE, EXCEPTION, RETRY)

def lastStep(step):
    allSteps = step.build.getStatus().getSteps()
    last = allSteps[-1]
    (started, finished) = last.getTimes()
    return started

class RefShellCommand(ShellCommand):
    name = "buildcommand"
    command = [name]
     
    def __init__(self, **kwargs):
        ShellCommand.__init__(self, **kwargs)   # always upcall!
	self.ref = None

    def createSummary(self, log):
        s = re.search("^Build reference: (\S+)$", log.getText(), re.MULTILINE)
	if s:
	    self.ref = s.group(1)

    def getText(self, cmd, results):
        if results != SKIPPED:
            text = ShellCommand.getText(self, cmd, results)
	else:
	    text = [ "skipped" ]
	if self.ref:
	    text.append(self.ref)
        return text

    def getText2(self, cmd, results):
        text = [ ]
	if self.ref:
	    text.append(self.ref)
        return text

    def maybeGetText2(self, cmd, results):
        # Add build reference if this step has been successful,
	# or if the previous step failed.
	text = [ ]
        if results == SUCCESS:
	    text = [ "<br/>" ]
            text.extend(self.getText2(cmd, results))
	elif lastStep(self):
	    text = [ "<br/>" ]
	    text.extend(self.getText2(cmd, results))
        return text

class AnalyzeLog(LogLineObserver):
    def __init__(self, **kwargs):
        LogLineObserver.__init__(self, **kwargs)   # always upcall!
        self.numTotal = 0
        self.numPassed = 0
        self.numFailed = 0
        self.numSkipped = 0
    def outLineReceived(self, line):
	# We look for:
	# Building <arch>:<config> ... passed
	# Building <arch>:<config> ... failed
	# Building <arch:<config> ... failed (config) - skipping
        if line.startswith("Building "):
            self.numTotal += 1
	    if passed.match(line):
                self.numPassed += 1
                self.step.setProgress('pass', self.numPassed)
	    if failed.match(line):
                self.numFailed += 1
                self.step.setProgress('fail', self.numFailed)
	    if skipped.match(line):
                self.numSkipped += 1
                self.step.setProgress('skipped', self.numSkipped)

class StableBuildCommand(RefShellCommand):
    name = "buildcommand"
    command = [name]
     
    def __init__(self, **kwargs):
        RefShellCommand.__init__(self, **kwargs)   # always upcall!
        self.counter = AnalyzeLog()
        self.addLogObserver('stdio', self.counter)
        self.progressMetrics += ('builds', 'pass', 'fail', 'skipped',)

    def getText(self, cmd, results):
        text = RefShellCommand.getText(self, cmd, results)
	# if results == SKIPPED:
	#     return text
	text.append("total: " + str(self.counter.numTotal))
        if self.counter.numPassed > 0:
            text.append("pass: " + str(self.counter.numPassed))
        if self.counter.numSkipped > 0:
            text.append("skipped: " + str(self.counter.numSkipped))
        if self.counter.numFailed > 0:
            text.append("fail: " + str(self.counter.numFailed))
        return text

    def getText2(self, cmd, results):
        text = RefShellCommand.getText2(self, cmd, results)
	# if results == SKIPPED:
	#     return text
	text.append("<br>");
	text.append("total: " + str(self.counter.numTotal))
        if self.counter.numPassed > 0:
            text.append("pass: " + str(self.counter.numPassed))
        if self.counter.numSkipped > 0:
            text.append("skipped: " + str(self.counter.numSkipped))
        if self.counter.numFailed > 0:
            text.append("fail: " + str(self.counter.numFailed))
        return text

    def maybeGetText2(self, cmd, results):
    	return self.getText2(cmd, results)

    def evaluateCommand(self, cmd):
        if self.counter.numFailed > 0:
	    if self.counter.numPassed == 0:
	        return FAILURE
            return WARNINGS
        else:
	    if self.counter.numPassed == 0:
	        self.build.result = SKIPPED
		return SKIPPED
            return SUCCESS

def isSkipped(result, s):
     return (result == SKIPPED)

def isSuccess(result, s):
     return (result == SUCCESS)

# hwmon builds

c['change_source'].append(GitPoller(
        hwmon_repo, project='hwmon', workdir='hwmon-workdir',
	branches=hwmon_branches, pollinterval=1057))

for branch in hwmon_branches:
    c['schedulers'].append(SingleBranchScheduler(
		name=branch,
		change_filter=filter.ChangeFilter(project='hwmon', branch=branch),
		treeStableTimer=600,
		builderNames=[ branch ]))
    force.append(branch)
    f = BuildFactory()
    f.addStep(Git(repourl=hwmon_repo, branch=branch, mode='full',
    		hideStepIf=isSuccess))
    f.addStep(ShellCommand(timeout=3600,
		description='building',
		descriptionDone='complete',
		command=["hwmon-build.sh"],
		env={'PATH': "/opt/buildbot/bin:${PATH}"}))
    c['builders'].append(
    	BuilderConfig(name=branch,
		slavenames=hwmon_slaves,
		factory=f,
		properties={"priority": 2},
		locks=[build_lock.access('counting')]))

# stable builds

c['change_source'].append(GitPoller(
        stable_repo, project='stable-queue', workdir='stable-workdir',
	branches=stable_queue_branches, pollinterval=600))

for b in stable_branches:
    builders = []
    if b == 'master':
        branch = b
    else:
        branch = "linux-%s.y.queue" % b
    for arch in stable_arches:
        name = "stable-queue-%s-%s" % (arch, b)
        builddir = "stable-queue-%s" % b
        builders.append(name)
        force.append(name)
        f = BuildFactory()
        f.addStep(Git(repourl=stable_repo, branch=branch, mode='full',
		hideStepIf=isSuccess))
        f.addStep(StableBuildCommand(timeout=3600,
    		description='building',
		descriptionDone='complete',
		command=["stable-build-arch.sh", arch],
		env={'PATH': "/opt/buildbot/bin:${PATH}"},
		warnOnWarnings=True))
        c['builders'].append(
		BuilderConfig(name=name, slavenames=stable_slaves, factory=f,
			slavebuilddir=builddir,
			properties={"priority": 3},
			locks=[build_lock.access('counting')]))
    qemu_targets = eval("qemu_targets_%s" % b.replace('.', ''))
    for t in qemu_targets:
	f = BuildFactory()
	cmd = "run-qemu-%s.sh" % t
	path = "/opt/buildbot/rootfs/%s:${PATH}" % t
	tname = "qemu-%s-%s" % (t, b)
	tbuilddir = "qemu-%s" % b
	builders.append(tname)
	force.append(tname)
	f.addStep(Git(repourl=stable_repo, branch=branch, mode='full',
		haltOnFailure=True, hideStepIf=isSuccess))
	f.addStep(RefShellCommand(timeout=1200,
		description='running',
		descriptionDone='complete',
		command=[ cmd ], env={'PATH': path},
		haltOnFailure=False, flunkOnFailure=False,
		warnOnWarnings=True))
	f.addStep(RefShellCommand(timeout=1200,
		description='running',
		descriptionDone='complete',
		command=[ cmd ], env={'PATH': path}, doStepIf=prevFailed,
		hideStepIf=isSkipped))
	c['builders'].append(
		BuilderConfig(name=tname, slavenames=stable_slaves, factory=f,
			slavebuilddir=tbuilddir,
			properties={"priority": 4},
			locks=[build_lock.access('counting')]))

    c['schedulers'].append(SingleBranchScheduler(
		name=name,
		change_filter=filter.ChangeFilter(project='stable-queue',
						branch=branch),
		treeStableTimer=120, builderNames=builders))

#
# stable repository import has its dedicated poller, scheduler,
# build factory, and builder.
#
c['change_source'].append(GitPoller(
        'git://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git',
	project='stable-updates',
        workdir='stable-updates-workdir',
	branches=['master'],
        pollinterval=600))

c['schedulers'].append(SingleBranchScheduler(
                            name="stable-updater",
                            change_filter=filter.ChangeFilter(project='stable-updates',
			    				branch='master'),
                            treeStableTimer=600,
                            builderNames=["stable-updates"]))

f_queue_import = BuildFactory()
# check out the source
f_queue_import.addStep(Git(repourl='git://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git',
		branch='master', mode='full', hideStepIf=isSuccess))
# update stable tree
f_queue_import.addStep(ShellCommand(command=["git-push-local.sh"],
		description='updating stable',
		descriptionDone='stable update done',
		haltOnFailure=True,
		env={'PATH': "/opt/buildbot/bin:${PATH}"}))

c['builders'].append(
    BuilderConfig(name="stable-updates",
	slavenames=[ "server" ],
	properties={"priority": 0},
	factory=f_queue_import))

force.append("stable-updates")

#
# stable queue import has its dedicated poller, scheduler,
# build factory, and builder.
#
c['change_source'].append(GitPoller(
        'git://git.kernel.org/pub/scm/linux/kernel/git/stable/stable-queue.git',
	project='stable-queue-import',
        workdir='queue-workdir',
	branches=['master'],
        pollinterval=1200))

c['schedulers'].append(SingleBranchScheduler(
                            name="stable-queue-import",
                            change_filter=filter.ChangeFilter(project='stable-queue-import',
			    				branch='master'),
                            treeStableTimer=1800,
                            builderNames=["stable-queue-import"]))

f_queue_import = BuildFactory()
# check out the source
f_queue_import.addStep(Git(repourl='git://git.kernel.org/pub/scm/linux/kernel/git/stable/stable-queue.git',
		branch='master', mode='full', hideStepIf=isSuccess))
# run the build
f_queue_import.addStep(ShellCommand(command=["stable-queue-update.sh"],
		description='updating queue',
		descriptionDone='queue update done',
		env={'PATH': "/opt/buildbot/bin:${PATH}"}))

c['builders'].append(
    BuilderConfig(name="stable-queue-import",
	slavenames=["server"],
	properties={"priority": 1},
	factory=f_queue_import))

force.append("stable-queue-import")

c['schedulers'].append(ForceScheduler( name="force", builderNames=force))

####### STATUS TARGETS

# 'status' is a list of Status Targets. The results of each build will be
# pushed to these targets. buildbot/status/*.py has a variety to choose from,
# including web pages, email senders, and IRC bots.

c['status'] = []

from buildbot.status import html
from buildbot.status.web import authz, auth

authz_cfg=authz.Authz(
    # change any of these to True to enable; see the manual for more
    # options
    auth=auth.HTPasswdAprAuth('/opt/buildbot/.htpasswd'),
    gracefulShutdown = 'auth',
    forceBuild = 'auth', # use this to test your slave once it is set up
    forceAllBuilds = 'auth',
    pingBuilder = 'auth',
    stopBuild = 'auth',
    stopAllBuilds = 'auth',
    cancelPendingBuild = 'auth',
)
c['status'].append(html.WebStatus(http_port=8010, authz=authz_cfg))

####### MAIL

from buildbot.status.mail import MailNotifier

mn = MailNotifier(fromaddr="linux@roeck-us.net",
		sendToInterestedUsers=False,
		extraRecipients=['linux@roeck-us.net'],
		builders = [ "stable-queue-import", "stable-updates" ]
	)

c['status'].append(mn)

####### PROJECT IDENTITY

# the 'title' string will appear at the top of this buildbot
# installation's html.WebStatus home page (linked to the
# 'titleURL') and is embedded in the title of the waterfall HTML page.

c['title'] = "Linux kernel hwmon and stable-queue builds"
c['titleURL'] = "http://server.roeck-us.net:8010"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server (usually the html.WebStatus page) is visible. This
# typically uses the port number set in the Waterfall 'status' entry, but
# with an externally-visible host name which the buildbot cannot figure out
# without some help.

c['buildbotURL'] = "http://server.roeck-us.net:8010/"

####### DB URL

c['db'] = {
    # This specifies what database buildbot uses to store its state.  You can leave
    # this at its default for all but the largest installations.
    'db_url' : "sqlite:///state.sqlite",
}
